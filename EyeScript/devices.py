# -*- coding: utf-8 -*-
"""Contains classes for monitoring the various input devices for responses.

EyeScript scripts normally will use ResponseCollector objects and the checkForResponse function in Experiment.py, rather than directly using the classes in this module.

When checkForResponse is called (either directly from the EyeScript script, or indirectly when a display is run), the poll method of each device is called, returning all
user events generated by that device since the last getEvents call.  The active ResponseCollectors are then notified of the events, if any.
"""
from experiment import getExperiment,getTracker,getLog,getDevice
import pygame, pylink
from event import ESevent
from constants import *
try:
    import win32com
    import win32com.client
    import pythoncom
    import win32api
except ImportError:
    win32com = None
    win32api = None
    pythoncom = None
try:
    import serial
except ImportError:
    serial = None

EYELINKBUTTONMAP = {1:"Y",2:"X",3:"B",4:"A",5:"left thumb",6:"left trigger",7:"right trigger"}
class EyeLinkButtonsDevice:
    """Handle communication with the EyeLink II gamepad controller.
    """
    def __init__(self):
        getTracker().flushKeybuttons(1)
    def poll(self):
        buttonBuffer = []
        while 1:
            event_type, button, button_change, key_code, time = getTracker().readKeyButton()
            if event_type == pylink.KB_BUTTON and button_change in [pylink.KB_PRESS,pylink.KB_RELEASE]:
                
                pgev = pygame.event.Event(button_change == pylink.KB_PRESS and EYELINK_BUTTON_DOWN or EYELINK_BUTTON_UP,
                                          
                                          {'key':EYELINKBUTTONMAP[button]}
                                          )
                buttonBuffer.append(ESevent(pgev,
                                            time=time
                                            ))
            elif not event_type:
                break
        return buttonBuffer

BBOXMAPPING = {0:4,6:3,5:2,2:1,1:5,4:6,3:7,7:8}
def byteToKey(byte):
    return (BBOXMAPPING[ord(byte)/32],(ord(byte)/16)%2)
class CedrusButtonsDevice:
    """Collect input from a Cedrus button box.
    """
    def __init__(self):
        if not serial:
            raise "serial module must be installed to use button box."
        try:
            self.port = serial.Serial(getExperiment()['buttonbox_com']-1,getExperiment()['buttonbox_baud'],timeout=0)
        except serial.SerialException:
            raise "Error trying to connect to button box at com %s, baud %s"%(getExperiment()['buttonbox_com'],getExperiment()['buttonbox_baud'])
        self.resetTime = pylink.currentTime()
        self.port.write("e5") # Reset the button box's rt timer
        self.buffer = []
        
##    def currentTime(self):
##        self.port.write("e3") # Query the button box for the current time, measured from when the master timer was reset
##        # The button box should return "e3" followed by four bytes indicating the time in base 256
##        self.port.timeout = None
##        self.buffer += self.port.read(6)
##        while True:
##            if self.buffer[-6:-4] == "e3":
##                # Split off the packet starting with "e3"
##                self.buffer,s = self.buffer[:-6],self.buffer[-6:]
##                return (256**3)*ord(s[5])+(256**2)*ord(s[4])+256*ord(s[3])+ord(s[2])
##            # If we didn't see e3 followed by four bytes,
##            # it's possible we got the end of an old packet... keep reading till we get the current one.
##            self.buffer += self.port.read(1)
##        self.port.timeout = 0

    def poll(self):
        events = []
        self.buffer += self.port.read(12)
        while True:
            try: packet_start = self.buffer[:-5].index("k")
            except ValueError: break
            s = self.buffer[packet_start:packet_start+6]
            key,down = byteToKey(s[1])
            events.append(ESevent(pygame.event.Event(down and CEDRUS_BUTTON_DOWN or CEDRUS_BUTTON_UP,key = key),
                                  time = self.resetTime + (256**3)*ord(s[5])+(256**2)*ord(s[4])+256*ord(s[3])+ord(s[2])
                                  ))
            del self.buffer[packet_start:packet_start+6]
        return events
        
        
class MouseDevice:
    """
    Define the mouse device, for holding a buffer of mouse input for Mouse response collectors to read from.
    """
    def __init__(self):
        pygame.event.set_allowed([MOUSEBUTTONUP,MOUSEBUTTONDOWN,MOUSEMOTION])
        pygame.mouse.set_visible(True)
    def poll(self):
        polltime = pylink.currentTime()
        events = pygame.event.get([MOUSEBUTTONUP,MOUSEBUTTONDOWN,MOUSEMOTION])
        return [ESevent(event,polltime) for event in events]

class KeyboardDevice:
    """
    Define the keyboard device, for holding a buffer of keyboard input for Keyboard response collectors to read from.
    """
    def __init__(self):
        pygame.event.set_allowed([KEYUP,KEYDOWN])
    def poll(self):
        polltime = pylink.currentTime()
        events = pygame.event.get([KEYUP,KEYDOWN])
        for event in events:
            if (event.type == KEYDOWN and
                ((event.key in [pygame.K_LSHIFT,pygame.K_RSHIFT] and event.mod & pygame.KMOD_CTRL and event.mod & pygame.KMOD_ALT) or
                 (event.key in [pygame.K_RCTRL,pygame.K_LCTRL] and event.mod & pygame.KMOD_SHIFT and event.mod & pygame.KMOD_ALT) or
                 (event.key in [pygame.K_LALT,pygame.K_RALT] and event.mod & pygame.KMOD_CTRL and event.mod & pygame.KMOD_SHIFT)
                 )
                ): # Ctrl-Alt-Shift pressed
                raise "Experiment aborted."
        return [ESevent(event,polltime) for event in events]


class ButtonBoxDevice:
    """Handles communication with the serial port connecting to the button box (or USB port impersonating a serial port). UNDER CONSTRUCTION
    """
    def __init__(self):
        """Open the serial port that the button box is connected to
        """
        if not serial:
            raise "serial module must be installed to use button box."
        try:
            self.bboxSerial = serial.Serial(self['bbox_com']-1,baud=self['bbox_baud'],timeout=0)
        except KeyError, ke:
            raise "%s not set in experiment parameters"%(ke.args[0])
        except serial.SerialException:
            raise "Button box not connected."
        self.bboxBuffer = []
        self.bboxPackets = []
    
    def poll(self):
        """Store data from the serial port that the button box is connected to.
        """
        self.bboxBuffer.append(self.bboxSerial.read(12))
        self.bboxPackets = []
        while True:
            try: respStart = self.bboxBuffer.index(BUTTONCHAR)
            except ValueError: break
            if len(self.bboxBuffer) >= 6+respStart:
                self.bboxPackets.append(self.bboxBuffer[respStart:respStart+6])
                self.bboxBuffer = self.bboxBuffer[respStart+6:]
            else: break
        return 



if win32com and win32api:
    class ContextEvents(win32com.client.getevents("SAPI.SpSharedRecoContext")):
        
        """The callback class that handles the events raised by the speech object.
        See "Automation | SpSharedRecoContext (Events)" in the MS Speech SDK
        online help for documentation of the other events supported. """
        def OnRecognition(self, StreamNumber, StreamPosition, RecognitionType, Result):
            """Called when a word/phrase is successfully recognized  -
            ie it is found in a currently open grammar with a sufficiently high
            confidence"""
            newResult = win32com.client.Dispatch(Result)
            pygame.event.post(pygame.event.Event(SPEECH_RECOGNITION,streamPosition=StreamPosition,
                                                 word = newResult.PhraseInfo.GetText(),
                                                 time = pylink.currentTime() - (win32api.GetTickCount() - newResult.Times.TickCount)
                                                 )
                              )

##        def OnFalseRecognition(self, StreamNumber, StreamPosition, Result):
##            newResult = win32com.client.Dispatch(Result)
##            pygame.event.post(pygame.event.Event(SPEECH_FALSERECOGNITION,streamPosition=StreamPosition,
##                                                 word = newResult.PhraseInfo.GetText(),
##                                                 time = newResult.Times.TickCount
##                                                 )
##                              )

##        def OnSoundStart(self, StreamNumber, StreamPosition):
##            pygame.event.post(pygame.event.Event(SPEECH_SOUNDSTART,streamPosition=StreamPosition))
##
##        def OnSoundEnd(self,StreamNumber,StreamPosition):
##            pygame.event.post(pygame.event.Event(SPEECH_SOUNDEND,streamPosition=StreamPosition))
else:
    ContextEvents = None

class EyeLinkDevice:
    """Collects sample, fixation and saccade events from the eyetracker.

    Does not actually add any events to the Experiment's event queue (to keep the queue from being too long).
    ResponseCollector objects which collect eyetracker data should use the getFloatData or getNewestSample methods
    of the eyetracker object to retrieve EyeLink data.  The poll method of the EyeLinkDevice class
    ensures that the datum returned by getFloatData or getNewestSample is up to date.
    """
    def __init__(self):
        getTracker().resetData()
    def poll(self):
        """Updates the most recent datum from the link, which can then be accessed by ResponseCollector objects using getTracker().getFloatData().
        """
        getTracker().getNextData()
        return []

class SpeechDevice:
    """Collect spoken responses using Microsoft's automatic speech recognition.
        
    Code adapted from http://surguy.net/articles/speechrecognition.xml
    """
            
    def __init__(self):
        if not pythoncom or not win32com or not ContextEvents:
            raise "win32com and pythoncom must be installed for speech recognition to work"
        self.knownWords = []
        # For speech recognition - first create a listener
        self.listener = win32com.client.Dispatch("SAPI.SpSharedRecognizer")
        # Then a recognition context
        self.context = self.listener.CreateRecoContext()
        # which has an associated grammar
        self.grammar = self.context.CreateGrammar()
        # Do not allow free word recognition - only command and control
        # recognizing the words in the grammar only
        self.grammar.DictationSetState(0)
        # Create a new rule for the grammar, that is top level (so it begins
        # a recognition) and dynamic (ie we can change it at runtime)
        self.wordsRule = self.grammar.Rules.Add("wordsRule",
                        win32com.client.constants.SRATopLevel + win32com.client.constants.SRADynamic, 0)
        # Clear the rule (not necessary first time, but if we're changing it
        # dynamically then it's useful)
        self.wordsRule.Clear()
        
        # Set the wordsRule to be active
        self.grammar.Rules.Commit()
        self.grammar.CmdSetRuleState("wordsRule", 1)
        # Commit the changes to the grammar
        self.grammar.Rules.Commit()
        # And add an event handler that's called back when recognition occurs
        self.eventHandler = ContextEvents(self.context)
        
    def poll(self):
        pythoncom.PumpWaitingMessages()
        return [ESevent(event,event.time) for event in pygame.event.get(SPEECH_RECOGNITION)]
        
    def addWords(self,words):
        """
        Add to the set of words which the speech recognition object recognizes.
        If the speech recognizer hasn't been created yet, we'll create it.
        This method also does some checking to make sure the words weren't already added.
        """
        #All words in knownWords will have the first letter capitalized
        #to make sure that we don't have two of the same word with different capitalizations
        words = [word.capitalize() for word in words]
        # Go through the list of words, adding each to the rule
        [ self.wordsRule.InitialState.AddWordTransition(None, word) for word in words
          if not (word in self.knownWords)] #Don't add any words that have already been added.
        #Record the rule change
        self.grammar.Rules.Commit()
        #Keep track of the added words to prevent them from being added again
        self.knownWords.extend(words)
